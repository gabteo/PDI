# -*- coding: utf-8 -*-
"""trabalho_ARROZ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qw8smiQOgt1P7VduBNQr7DQoN5b2Cfi2
"""
import matplotlib.pyplot as plt
import sys
import statistics
import timeit
import numpy as np
import cv2
#from scipy import stats


# ===============================================================================

#IMAGES = '60.bmp', '82.bmp', '114.bmp', '150.bmp', '205.bmp'
IMAGES = '60.bmp', '82.bmp', 
# ===============================================================================


def inunda(img, row, col, label, n_pixels):
    img[row, col] = label
    n_pixels = n_pixels + 1
    rows, cols = img.shape

    # vizinho-8
    vizinhos = [(col-1, row), (col+1, row), (col-1, row-1), (col+1, row+1),
                (col-1, row+1), (col+1, row-1), (col, row-1), (col, row+1)]

    for vizinho in vizinhos:
        value = img[vizinho[1], vizinho[0]]
        if 0 <= vizinho[0] < cols and 0 <= vizinho[1] < rows and value == 255.0:
            n_pixels = inunda(img, vizinho[1], vizinho[0], label, n_pixels)

    return n_pixels


def label(img):
    labels = 0.1
    n_pixels_min = 50  # 60 , 30
    comp_list = []

    rows, cols = img.shape
    for row in range(rows):
        for col in range(cols):
            value = img[row, col]
            if value == 255.0:
                n_pixels = 0
                n_pixels = inunda(img, row, col, labels, n_pixels)
                if n_pixels >= n_pixels_min:
                    comp = {
                        "label": labels,
                        "n_pixels": n_pixels
                    }
                    comp_list.append(comp)
                labels += 0.1

    return comp_list


def makePixelArr(components):
    pixel_arr = []
    for blob in components:
        pixel_arr.append(blob['n_pixels'])

    return np.sort(pixel_arr)


def separateOutliers(pixel_arr):
    smallOut = []
    notOut = []
    bigOut = []

    q1 = np.percentile(pixel_arr, 25)
    q3 = np.percentile(pixel_arr, 75)
    iqr = (q3 - q1)

    for blobSize in pixel_arr:
        if blobSize < (q1 - (1.5*iqr)):
            smallOut.append(blobSize)

        elif blobSize > (q3 + (1.5*iqr)):
            bigOut.append(blobSize)

        else:
            notOut.append(blobSize)

    return np.sort(smallOut), np.sort(notOut), np.sort(bigOut)


def blobAnalysis(blob):
    return


def blobListAnalysis(blob_arr, threshold, div):
    count = 0
    for blob in blob_arr:
        if blob <= threshold:  # menor que o threshold = 1 grao
            count += 1
        else:  # maior que o threshold - 1 ou mais graos
            amount = blob // threshold
            rest = blob % threshold

            rest = rest // div
            amount += rest
            count += amount

    return count


def getK(arr, threshold):
    if len(arr) == 0 or np.std(arr) < 100:
        return 1
    else:
        return threshold / (np.std(arr)*1.5)


def countGrains(components):
    grains = 0

    pixel_arr = makePixelArr(components)

    sOut, nOut, bOut = separateOutliers(pixel_arr)

    threshold = np.mean(nOut)
    div = np.min(pixel_arr)

    k = getK(nOut, threshold)
    divv = div * k
    if divv < div:
        divv = div

    n_sOut = blobListAnalysis(sOut, threshold, divv)
    n_nOut = blobListAnalysis(nOut, threshold, divv)
    n_bOut = blobListAnalysis(bOut, threshold, divv)

    return (n_sOut + n_nOut + n_bOut)

# ===============================================================================


def main():
    sys.setrecursionlimit(1000000)
    for img_input in IMAGES:
        # Abre a imagem em escala de cinza.
        img = cv2.imread(img_input, cv2.IMREAD_GRAYSCALE)
        if img is None:
            print('Erro abrindo a imagem.\n')
            sys.exit()

        # É uma boa prática manter o shape com 3 valores, independente da imagem ser
        # colorida ou não. Também já convertemos para float32.
        img = img.reshape((img.shape[0], img.shape[1], 1))
        img = img.astype(np.float32) / 255

        # Mantém uma cópia colorida para desenhar a saída.
        img_out = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)

        img = img*255
        gauss = cv2.GaussianBlur(img, (401, 401), 0)
        cv2.imshow('img-gauss', gauss)
        img2 = img[:, :, 0] - gauss
        cv2.imshow('img-det', img2)
        
        img_gauss = img2.astype(np.uint8)
        _, thresh = cv2.threshold(img2, 60, 255, cv2.THRESH_BINARY)
        cv2.imshow('img-thresh', thresh)
        img_median = cv2.medianBlur(thresh, 5)
        cv2.imshow('img-median1', img_median)
        img_median = cv2.medianBlur(img_median, 5)
        cv2.imshow('img-median2', img_median)

        cmpnts = label(img_median)

        print('img: ', img_input)
        count = countGrains(cmpnts)
        print('# graos de arroz encontrados: ', count, '\n')

    cv2.waitKey()
    cv2.destroyAllWindows()


if __name__ == '__main__':
    main()

# ===============================================================================
